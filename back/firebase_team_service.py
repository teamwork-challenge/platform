import uuid
from typing import List, Optional

from api_models import TeamCreateRequest, AuthData, UserRole, Team as APITeam
from back.firebase_db import get_firestore_db
from back.firebase_models import TeamDocument, APIKeyDocument


class TeamService:
    def __init__(self) -> None:
        self.db = get_firestore_db()

    def get_team(self, team_id: str, challenge_id: str) -> Optional[APITeam]:
        """Get team by ID from a specific challenge (teams are stored as a subcollection)."""
        team_ref = self.db.collection('challenges').document(challenge_id).collection('teams').document(team_id)
        team_doc = team_ref.get()
        if not team_doc.exists:
            return None
        return APITeam.model_validate(team_doc.to_dict())

    def rename_team(self, team_id: str, challenge_id: str, new_name: str) -> Optional[APITeam]:
        """Rename a team by updating its 'name' field. Returns updated team or None if not found."""
        team_ref = self.db.collection('challenges').document(challenge_id).collection('teams').document(team_id)
        team_doc = team_ref.get()
        if not team_doc.exists:
            return None
        team_ref.update({"name": new_name})
        # Read back the updated document
        updated_doc = team_ref.get()
        return APITeam.model_validate(updated_doc.to_dict())

    def create_teams(self, challenge_id: str, teams: List[TeamCreateRequest]) -> List[APITeam]:
        """Create multiple teams for a challenge using subcollection and autogenerated IDs."""
        created_teams: List[APITeam] = []
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            raise ValueError(f"Challenge {challenge_id} not found")

        for team_data in teams:
            # Autogenerate team document ID in subcollection
            team_ref = challenge_ref.collection('teams').document()
            team_id = team_ref.id
            api_key = str(uuid.uuid4())

            # Create team document
            team_doc = TeamDocument(
                id=team_id,
                challenge_id=challenge_id,
                name=team_data.name,
                members=team_data.members,
                captain_contact=team_data.captain_contact
            )
            team_ref.set(team_doc.model_dump())

            # Create API key document
            api_key_doc = APIKeyDocument(
                key=api_key,
                challenge_id=challenge_id,
                role="player",
                team_id=team_id
            )
            self.db.collection('keys').document(api_key).set(api_key_doc.model_dump())

            # Response team object (do not expose api_key in listings; here we return it)
            api_team = APITeam.model_validate(team_doc, from_attributes=True)
            api_team.api_key = api_key
            created_teams.append(api_team)

        return created_teams

    def get_teams_by_challenge(self, challenge_id: str) -> List[APITeam]:
        """Get all teams for a specific challenge from the teams subcollection"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            return []
        teams: List[APITeam] = []
        for team_doc in challenge_ref.collection('teams').stream():
            td = team_doc.to_dict()
            api_team = APITeam.model_validate({
                'id': team_doc.id,
                'challenge_id': challenge_id,
                'name': td['name'],
                'members': td['members'],
                'captain_contact': td['captain_contact'],
                'api_key': "",
                'total_score': td.get('total_score', 0)
            })
            teams.append(api_team)
        return teams


    def get_all_teams(self) -> List[APITeam]:
        """Get all teams across all challenges (iterate subcollections)."""
        teams: List[APITeam] = []
        for ch_doc in self.db.collection('challenges').stream():
            ch_id = ch_doc.id
            for team_doc in self.db.collection('challenges').document(ch_id).collection('teams').stream():
                td = team_doc.to_dict()
                teams.append(APITeam.model_validate({
                    'id': team_doc.id,
                    'challenge_id': ch_id,
                    'name': td['name'],
                    'members': td['members'],
                    'captain_contact': td['captain_contact'],
                    'api_key': "",
                    'total_score': td.get('total_score', 0)
                }))
        return teams

    def get_auth_data(self, api_key: str) -> Optional[AuthData]:
        """Get authentication data for an API key"""
        key_ref = self.db.collection('keys').document(api_key)
        key_doc = key_ref.get()

        if not key_doc.exists:
            return None

        key_data = key_doc.to_dict()

        if key_data['role'] == 'admin':
            return AuthData(
                key=key_data['key'],
                role=UserRole.ADMIN,
            )
        else:
            challenge_id = key_data['challenge_id']
            team_id = key_data['team_id']
            challenge_ref = self.db.collection('challenges').document(challenge_id)
            current_round_id = None
            rounds_ref = challenge_ref.collection('rounds')
            for rd in rounds_ref.stream():
                rd_data = rd.to_dict()
                if rd_data.get('published', False):
                    current_round_id = rd.id
                    break

            return AuthData(
                key=api_key,
                role=UserRole.PLAYER,
                team_id=team_id,
                challenge_id=challenge_id,
                round_id=current_round_id,
            )
