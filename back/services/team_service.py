import uuid
from typing import List, Optional

from api_models import TeamCreateRequest, AuthData, UserRole, Team as APITeam
from back.services.db import get_firestore_db
from back.db_models import TeamDocument, APIKeyDocument


class TeamService:
    def __init__(self) -> None:
        self.db = get_firestore_db()
        # local in-memory auth cache (api_key -> AuthData)
        from datetime import timedelta
        from back.services.cache import InMemoryCache
        from api_models import AuthData as _AuthData
        self._auth_cache: InMemoryCache[_AuthData] = InMemoryCache(default_ttl=timedelta(minutes=10))

    def get_team(self, team_id: str, challenge_id: str) -> Optional[APITeam]:
        """Get team by ID from a specific challenge (teams are stored as a subcollection)."""
        team_ref = self.db.collection('challenges').document(challenge_id).collection('teams').document(team_id)
        team_doc = team_ref.get()
        if not team_doc.exists:
            return None
        return APITeam.model_validate(team_doc.to_dict())

    def rename_team(self, team_id: str, challenge_id: str, new_name: str) -> APITeam:
        """Rename a team by updating its 'name' field. Returns updated team or None if not found."""
        team_ref = self.db.collection('challenges').document(challenge_id).collection('teams').document(team_id)
        team_doc = team_ref.get()
        if not team_doc.exists:
            raise ValueError(f"Team {team_id} not found")
        team_ref.update({"name": new_name})
        # Read back the updated document
        updated_doc = team_ref.get()
        return APITeam.model_validate(updated_doc.to_dict())

    def create_teams(self, challenge_id: str, teams: List[TeamCreateRequest]) -> List[APITeam]:
        """Create multiple teams for a challenge using subcollection and autogenerated IDs."""
        created_teams: List[APITeam] = []
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            raise ValueError(f"Challenge {challenge_id} not found")

        for team_data in teams:
            # Autogenerate team document ID in subcollection
            team_ref = challenge_ref.collection('teams').document()
            team_id = team_ref.id
            api_key = str(uuid.uuid4())

            # Create team document
            team_doc = TeamDocument(
                id=team_id,
                challenge_id=challenge_id,
                name=team_data.name,
                members=team_data.members,
                captain_contact=team_data.captain_contact
            )
            team_ref.set(team_doc.model_dump())

            # Create API key document
            api_key_doc = APIKeyDocument(
                key=api_key,
                challenge_id=challenge_id,
                role="player",
                team_id=team_id
            )
            self.db.collection('keys').document(api_key).set(api_key_doc.model_dump())

            # Response team object (do not expose api_key in listings; here we return it)
            api_team = APITeam.model_validate(team_doc, from_attributes=True)
            api_team.api_key = api_key
            created_teams.append(api_team)

        return created_teams

    def get_teams_by_challenge(self, challenge_id: str) -> List[APITeam]:
        """Get all teams for a specific challenge from the teams subcollection, including api_keys."""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            return []
        teams: List[APITeam] = []
        # Build a mapping from team_id -> api_key for this challenge to include keys in the response
        keys_ref = self.db.collection('keys')
        team_keys: dict[str, str] = {}
        for key_doc in keys_ref.where('challenge_id', '==', challenge_id).stream():
            data = key_doc.to_dict()
            team_id = data.get('team_id')
            key = data.get('key') or key_doc.id
            if team_id:
                team_keys[str(team_id)] = str(key)
        for team_doc in challenge_ref.collection('teams').stream():
            team_data = team_doc.to_dict()
            api_team = APITeam.model_validate(team_data)
            # Attach api_key if known
            api_key = team_keys.get(str(api_team.id), "")
            api_team.api_key = api_key
            teams.append(api_team)
        return teams


    def get_auth_data(self, api_key: str) -> Optional[AuthData]:
        """Get authentication data for an API key with local in-memory caching.
        Cache invalidates after 10 minutes by default and at the end of the current round for players.
        """
        # Try cache first
        cached = self._auth_cache.get(api_key)
        if cached is not None:
            return cached

        key_ref = self.db.collection('keys').document(api_key)
        key_doc = key_ref.get()

        if not key_doc.exists:
            return None

        key_data = key_doc.to_dict()

        if key_data['role'] == 'admin':
            auth = AuthData(
                key=key_data['key'],
                role=UserRole.ADMIN,
            )
            # cache admin auth with default TTL
            self._auth_cache.set(api_key, auth)
            return auth
        else:
            challenge_id = key_data['challenge_id']
            team_id = key_data['team_id']
            challenge = self.db.collection('challenges').document(challenge_id).get().to_dict()
            round_id = challenge['current_round_id']

            auth = AuthData(
                key=api_key,
                role=UserRole.PLAYER,
                team_id=team_id,
                challenge_id=challenge_id,
                round_id=round_id
            )

            self._auth_cache.set(api_key, auth)
            return auth
