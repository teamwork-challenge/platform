from typing import List, Optional, Any, Tuple

from api_models import (
    ChallengeUpdateRequest, RoundCreateRequest, RoundUpdateRequest, RoundTaskTypeCreateRequest,
    Challenge as APIChallenge, Round as APIRound, RoundTaskType as APIRoundTaskType
)
from back.firebase_db import get_firestore_db
from back.firebase_models import ChallengeDocument, RoundDocument, TaskTypeDocument


class ChallengeService:
    def __init__(self) -> None:
        self.db = get_firestore_db()

    # Challenge CRUD
    def get_challenge(self, challenge_id: str) -> Optional[APIChallenge]:
        """Get challenge by ID"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()
        if not challenge_doc.exists:
            return None
        challenge_data = challenge_doc.to_dict()
        return APIChallenge.model_validate(challenge_data)

    def get_all_challenges(self) -> List[APIChallenge]:
        """Get all challenges"""
        challenges = []
        challenge_docs = self.db.collection('challenges').stream()

        for challenge_doc in challenge_docs:
            challenge_data = challenge_doc.to_dict()
            api_challenge = APIChallenge.model_validate(challenge_data)
            challenges.append(api_challenge)

        return challenges

    def create_challenge(self, title: str, description: str) -> APIChallenge:
        """Create a new challenge"""
        # Use Firestore autogenerated document ID
        challenge_ref = self.db.collection('challenges').document()
        challenge_id = challenge_ref.id
        
        challenge_doc = ChallengeDocument(
            id=challenge_id,
            title=title,
            description=description,
        )

        data = challenge_doc.model_dump()
        data['id'] = challenge_id
        data['current_round_id'] = None
        self.db.collection('challenges').document(challenge_id).set(data)

        return APIChallenge.model_validate(data)

    def update_challenge(self, challenge_id: str, update: ChallengeUpdateRequest) -> Optional[APIChallenge]:
        """Update a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()

        if not challenge_doc.exists:
            return None

        challenge_data = challenge_doc.to_dict()

        # Update fields
        if update.title is not None:
            challenge_data['title'] = update.title
        if update.description is not None:
            challenge_data['description'] = update.description
        if update.current_round_id is not None:
            challenge_data['current_round_id'] = update.current_round_id

        challenge_ref.set(challenge_data)

        return self.get_challenge(challenge_id)


    def delete_challenge(self, challenge_id: str) -> Optional[APIChallenge]:
        """Delete a challenge (soft delete by marking deleted field)"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()
        
        if not challenge_doc.exists:
            return None
            
        challenge_data = challenge_doc.to_dict()
        challenge_data['deleted'] = True
        
        challenge_ref.set(challenge_data)
        
        return self.get_challenge(challenge_id)

    # Rounds
    def create_round(self, round_data: RoundCreateRequest) -> APIRound:
        """Create a new round for a challenge"""
        challenge_id = round_data.challenge_id
        # Use Firestore autogenerated ID from a subcollection to generate a round ID string
        round_ref = self.db.collection('challenges').document(challenge_id).collection('rounds').document()
        round_id = round_ref.id
        
        # Ensure challenge exists
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            raise ValueError(f"Challenge {challenge_id} not found")
        
        round_doc = RoundDocument(
            id=round_id,
            challenge_id=challenge_id,
            published=False,
            claim_by_type=round_data.claim_by_type,
            start_time=round_data.start_time,
            end_time=round_data.end_time,
        )
        
        # Store round as a subcollection document
        round_ref.set(round_doc.model_dump())
        return APIRound.model_validate(round_doc, from_attributes=True)

    def get_rounds_by_challenge(self, challenge_id: str) -> List[APIRound]:
        """Get all rounds for a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            return []
        
        rounds: List[APIRound] = []
        for round_doc in challenge_ref.collection('rounds').stream():
            rd = round_doc.to_dict()
            rounds.append(APIRound.model_validate(rd))
        
        return rounds

    def get_round(self, round_id: str, challenge_id: str) -> Optional[RoundDocument]:
        """Get a specific round by ID. Requires challenge_id; no scanning fallbacks."""
        ch_ref = self.db.collection('challenges').document(challenge_id)
        rd_ref = ch_ref.collection('rounds').document(round_id)
        rd_doc = rd_ref.get()
        if rd_doc.exists:
            return RoundDocument.model_validate(rd_doc.to_dict())
        return None

    # Round Task Types
    def create_round_task_type(self, task_type_data: RoundTaskTypeCreateRequest, challenge_id: str) -> APIRoundTaskType:
        """Create a round task type under the specified challenge/round. No fallbacks."""
        round_id = task_type_data.round_id
        # Ensure round exists under the challenge
        ch_ref = self.db.collection('challenges').document(challenge_id)
        rd_ref = ch_ref.collection('rounds').document(round_id)
        if not rd_ref.get().exists:
            raise ValueError(f"Round {round_id} not found in challenge {challenge_id}")
        
        # Create task type as a subdocument with autogenerated ID
        task_type_ref = rd_ref.collection('task_types').document()
        task_type_id = task_type_ref.id
        task_type_doc = TaskTypeDocument(
            task_type=task_type_data.type,
            challenge_id=challenge_id,
            round_id=round_id,
            tasks_count=task_type_data.max_tasks_per_team or 100,
            generator_url=task_type_data.generator_url,
            generator_settings=task_type_data.generator_settings or "",
            generator_secret=task_type_data.generator_secret,
            score=task_type_data.score or 100,
            time_to_solve=task_type_data.time_to_solve
        )
        task_type_ref.set(task_type_doc.model_dump())
        
        api_task_type_data = {
            'id': task_type_id,
            'round_id': round_id,
            'type': task_type_data.type,
            'generator_url': task_type_data.generator_url,
            'generator_settings': task_type_data.generator_settings,
            'generator_secret': task_type_data.generator_secret,
            'max_tasks_per_team': task_type_data.max_tasks_per_team or 100,
            'score': task_type_data.score or 100,
            'time_to_solve': task_type_data.time_to_solve
        }
        return APIRoundTaskType.model_validate(api_task_type_data)

    def get_round_task_types_by_round(self, round_id: str, challenge_id: str) -> List[APIRoundTaskType]:
        """List task types for a given round. Requires challenge_id; no fallbacks."""
        types: List[APIRoundTaskType] = []
        for tt_doc in self.db.collection('challenges').document(challenge_id) \
                .collection('rounds').document(round_id) \
                .collection('task_types').stream():
            td = tt_doc.to_dict()
            types.append(APIRoundTaskType.model_validate({
                'id': tt_doc.id,
                'round_id': round_id,
                'type': td['task_type'],
                'generator_url': td['generator_url'],
                'generator_settings': td.get('generator_settings'),
                'generator_secret': td['generator_secret'],
                'max_tasks_per_team': td['tasks_count'],
                'score': td['score'],
                'time_to_solve': td['time_to_solve']
            }))
        return types

    def _find_task_type_ref(self, task_type_id: str, challenge_id: str, round_id: str) -> Optional[tuple[Any, str, Any, Any]]:
        """Internal: find the Firestore reference and parent info for a task type by its document ID under known challenge/round."""
        ch_ref = self.db.collection('challenges').document(challenge_id)
        tt_ref = ch_ref.collection('rounds').document(round_id).collection('task_types').document(task_type_id)
        tt_doc = tt_ref.get()
        if tt_doc.exists:
            return ch_ref, round_id, tt_ref, tt_doc
        return None

    def get_round_task_type(self, task_type_id: str, challenge_id: str, round_id: str) -> Optional[APIRoundTaskType]:
        found = self._find_task_type_ref(task_type_id, challenge_id, round_id)
        if not found:
            return None
        _, _, _, tt_doc = found
        td = tt_doc.to_dict()
        return APIRoundTaskType.model_validate({
            'id': tt_doc.id,
            'round_id': round_id,
            'type': td['task_type'],
            'generator_url': td['generator_url'],
            'generator_settings': td.get('generator_settings'),
            'generator_secret': td['generator_secret'],
            'max_tasks_per_team': td['tasks_count'],
            'score': td['score'],
            'time_to_solve': td['time_to_solve']
        })

    def update_round_task_type(self, task_type_id: str, task_type_data: RoundTaskTypeCreateRequest, challenge_id: str, round_id: str) -> Optional[APIRoundTaskType]:
        found = self._find_task_type_ref(task_type_id, challenge_id, round_id)
        if not found:
            return None
        _, _, tt_ref, _ = found
        updated_doc = TaskTypeDocument(
            task_type=task_type_data.type,
            challenge_id=challenge_id,
            round_id=round_id,
            tasks_count=task_type_data.max_tasks_per_team or 100,
            generator_url=task_type_data.generator_url,
            generator_settings=task_type_data.generator_settings or "",
            generator_secret=task_type_data.generator_secret,
            score=task_type_data.score or 100,
            time_to_solve=task_type_data.time_to_solve
        )
        tt_ref.set(updated_doc.model_dump())
        return self.get_round_task_type(task_type_id, challenge_id, round_id)

    def delete_round_task_type(self, task_type_id: str, challenge_id: str, round_id: str) -> Optional[APIRoundTaskType]:
        found = self._find_task_type_ref(task_type_id, challenge_id, round_id)
        if not found:
            return None
        _, _, tt_ref, tt_doc = found
        deleted = self.get_round_task_type(task_type_id, challenge_id, round_id)
        tt_ref.delete()
        return deleted

    def update_round(self, round_id: str, round_data: RoundUpdateRequest, challenge_id: str) -> Optional[APIRound]:
        rd_ref = self.db.collection('challenges').document(challenge_id).collection('rounds').document(round_id)
        rd_doc = rd_ref.get()
        if not rd_doc.exists:
            return None
        rd = rd_doc.to_dict()
        rd['published'] = round_data.published
        if round_data.claim_by_type is not None:
            rd['claim_by_type'] = round_data.claim_by_type
        if round_data.start_time is not None:
            rd['start_time'] = round_data.start_time
        if round_data.end_time is not None:
            rd['end_time'] = round_data.end_time
        rd_ref.set(rd)
        return APIRound.model_validate(rd)

    def delete_round(self, round_id: str, challenge_id: str) -> None:
        rd_ref = self.db.collection('challenges').document(challenge_id).collection('rounds').document(round_id)
        if rd_ref.get().exists:
            rd_ref.delete()
        return