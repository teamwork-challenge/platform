from typing import List, Optional, Any

from api_models import (
    Challenge as APIChallenge, Round as APIRound, RoundTaskType as APIRoundTaskType
)
from back.firebase_db import get_firestore_db
from back.firebase_models import ChallengeDocument, RoundDocument


class ChallengeService:
    def __init__(self) -> None:
        self.db = get_firestore_db()

    # Challenge CRUD
    def get_challenge(self, challenge_id: str) -> Optional[APIChallenge]:
        """Get challenge by ID"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()
        if not challenge_doc.exists:
            return None
        challenge_data = challenge_doc.to_dict()
        return APIChallenge.model_validate(challenge_data)

    def get_all_challenges(self) -> List[APIChallenge]:
        """Get all challenges"""
        challenges = []
        challenge_docs = self.db.collection('challenges').stream()

        for challenge_doc in challenge_docs:
            challenge_data = challenge_doc.to_dict()
            api_challenge = APIChallenge.model_validate(challenge_data)
            challenges.append(api_challenge)

        return challenges

    def create_challenge(self, title: str, description: str) -> APIChallenge:
        """Create a new challenge"""
        # Use Firestore autogenerated document ID
        challenge_ref = self.db.collection('challenges').document()
        challenge_id = challenge_ref.id
        
        challenge_doc = ChallengeDocument(
            id=challenge_id,
            title=title,
            description=description
        )

        data = challenge_doc.model_dump()
        self.db.collection('challenges').document(challenge_id).set(data)
        return APIChallenge.model_validate(data)

    def update_challenge(self, challenge_id: str, update: APIChallenge) -> Optional[APIChallenge]:
        """Update a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_ref.set(update.model_dump())
        return self.get_challenge(challenge_id)

    def get_rounds_by_challenge(self, challenge_id: str) -> List[APIRound]:
        """Get all rounds for a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            return []
        
        rounds: List[APIRound] = []
        for round_doc in challenge_ref.collection('rounds').stream():
            rounds.append(APIRound.model_validate(round_doc.to_dict()))
        
        return rounds

    def get_round(self, round_id: str, challenge_id: str) -> Optional[RoundDocument]:
        ch_ref = self.db.collection('challenges').document(challenge_id)
        rd_ref = ch_ref.collection('rounds').document(round_id)
        rd_doc = rd_ref.get()
        if rd_doc.exists:
            return RoundDocument.model_validate(rd_doc.to_dict())
        return None


    def get_round_task_types_by_round(self, round_id: str, challenge_id: str) -> List[APIRoundTaskType]:
        """List task types for a given round. Requires challenge_id; no fallbacks."""
        types: List[APIRoundTaskType] = []
        for tt_doc in self.db.collection('challenges').document(challenge_id) \
                .collection('rounds').document(round_id) \
                .collection('task_types').stream():
            round_task_type = APIRoundTaskType.model_validate(tt_doc.to_dict())
            types.append(round_task_type)
        return types


    def get_round_task_type(self, task_type_id: str, challenge_id: str, round_id: str) -> APIRoundTaskType:
        doc = self.db.collection('challenges').document(challenge_id) \
                 .collection('rounds').document(round_id) \
                 .collection('task_types').document(task_type_id) \
                 .get()
        if not doc.exists:
            raise ValueError("Task type not found")
        return APIRoundTaskType.model_validate(doc.to_dict())


    def update_round(self, round_data: APIRound) -> APIRound:
        rd_ref = self.db.collection('challenges').document(round_data.challenge_id).collection('rounds').document(round_data.id)
        doc = RoundDocument.model_validate(round_data, from_attributes=True)
        rd_ref.set(doc.model_dump())
        tts = rd_ref.collection('task_types')
        ids = {}
        for tt in round_data.task_types or []:
            tts.document(tt.type).set(tt.model_dump())
            ids[tt.type] = 1
        existing = list(tts.stream())
        batch = self.db.batch()
        for snap in existing:
            if snap.id not in ids:
                batch.delete(snap.reference)
        batch.commit()
        return round_data


    def delete_round(self, round_id: str, challenge_id: str) -> None:
        rd_ref = self.db.collection('challenges').document(challenge_id).collection('rounds').document(round_id)
        if rd_ref.get().exists:
            rd_ref.delete()
        return