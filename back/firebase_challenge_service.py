from typing import List, Optional, Any

from api_models import (
    Challenge as APIChallenge, Round as APIRound, RoundTaskType as APIRoundTaskType
)
from back.firebase_db import get_firestore_db
from back.firebase_models import ChallengeDocument, RoundDocument


class ChallengeService:
    def __init__(self) -> None:
        self.db = get_firestore_db()

    # Challenge CRUD
    def get_challenge(self, challenge_id: str) -> Optional[APIChallenge]:
        """Get challenge by ID"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()
        if not challenge_doc.exists:
            return None
        challenge_data = challenge_doc.to_dict()
        return APIChallenge.model_validate(challenge_data)

    def get_all_challenges(self) -> List[APIChallenge]:
        """Get all challenges"""
        challenges = []
        challenge_docs = self.db.collection('challenges').stream()

        for challenge_doc in challenge_docs:
            challenge_data = challenge_doc.to_dict()
            api_challenge = APIChallenge.model_validate(challenge_data)
            challenges.append(api_challenge)

        return challenges

    def create_challenge(self, title: str, description: str) -> APIChallenge:
        """Create a new challenge"""
        # Use Firestore autogenerated document ID
        challenge_ref = self.db.collection('challenges').document()
        challenge_id = challenge_ref.id
        
        challenge_doc = ChallengeDocument(
            id=challenge_id,
            title=title,
            description=description,
        )

        data = challenge_doc.model_dump()
        data['id'] = challenge_id
        data['current_round_id'] = None
        self.db.collection('challenges').document(challenge_id).set(data)

        return APIChallenge.model_validate(data)

    def update_challenge(self, challenge_id: str, update: APIChallenge) -> Optional[APIChallenge]:
        """Update a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_ref.set(update.model_dump())
        return self.get_challenge(challenge_id)


    def delete_challenge(self, challenge_id: str) -> Optional[APIChallenge]:
        """Delete a challenge (soft delete by marking deleted field)"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()
        
        if not challenge_doc.exists:
            return None
            
        challenge_data = challenge_doc.to_dict()
        challenge_data['deleted'] = True
        
        challenge_ref.set(challenge_data)
        
        return self.get_challenge(challenge_id)

    def get_rounds_by_challenge(self, challenge_id: str) -> List[APIRound]:
        """Get all rounds for a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            return []
        
        rounds: List[APIRound] = []
        for round_doc in challenge_ref.collection('rounds').stream():
            rd = round_doc.to_dict()
            rounds.append(APIRound.model_validate(rd))
        
        return rounds

    def get_round(self, round_id: str, challenge_id: str) -> Optional[RoundDocument]:
        """Get a specific round by ID. Requires challenge_id; no scanning fallbacks."""
        ch_ref = self.db.collection('challenges').document(challenge_id)
        rd_ref = ch_ref.collection('rounds').document(round_id)
        rd_doc = rd_ref.get()
        if rd_doc.exists:
            return RoundDocument.model_validate(rd_doc.to_dict())
        return None


    def get_round_task_types_by_round(self, round_id: str, challenge_id: str) -> List[APIRoundTaskType]:
        """List task types for a given round. Requires challenge_id; no fallbacks."""
        types: List[APIRoundTaskType] = []
        for tt_doc in self.db.collection('challenges').document(challenge_id) \
                .collection('rounds').document(round_id) \
                .collection('task_types').stream():
            types.append(APIRoundTaskType.model_validate(tt_doc.to_dict()))
        return types


    def _find_task_type_ref(self, task_type_id: str, challenge_id: str, round_id: str) -> Optional[tuple[Any, str, Any, Any]]:
        """Internal: find the Firestore reference and parent info for a task type by its document ID under known challenge/round."""
        ch_ref = self.db.collection('challenges').document(challenge_id)
        tt_ref = ch_ref.collection('rounds').document(round_id).collection('task_types').document(task_type_id)
        tt_doc = tt_ref.get()
        if tt_doc.exists:
            return ch_ref, round_id, tt_ref, tt_doc
        raise ValueError("Task type not found")


    def get_round_task_type(self, task_type_id: str, challenge_id: str, round_id: str) -> APIRoundTaskType:
        _, _, _, tt_doc = self._find_task_type_ref(task_type_id, challenge_id, round_id)
        td = tt_doc.to_dict()
        return APIRoundTaskType.model_validate(td)


    def update_round(self, round_data: APIRound) -> APIRound:
        rd_ref = self.db.collection('challenges').document(round_data.challenge_id).collection('rounds').document(round_data.id)
        doc = RoundDocument.model_validate(round_data, from_attributes=True)
        rd_ref.set(doc.model_dump())
        tts = rd_ref.collection('task_types')
        ids = {}
        for tt in round_data.task_types or []:
            tts.document(tt.type).set(tt.model_dump())
            ids[tt.type] = 1
        existing = list(tts.stream())
        batch = self.db.batch()
        for snap in existing:
            if snap.id not in ids:
                batch.delete(snap.reference)
        batch.commit()
        return round_data


    def delete_round(self, round_id: str, challenge_id: str) -> None:
        rd_ref = self.db.collection('challenges').document(challenge_id).collection('rounds').document(round_id)
        if rd_ref.get().exists:
            rd_ref.delete()
        return