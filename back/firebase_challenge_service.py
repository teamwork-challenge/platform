from typing import List, Optional

from api_models import (
    Challenge as APIChallenge, Round as APIRound, RoundTaskType as APIRoundTaskType
)
from back.firebase_db import get_firestore_db
from back.firebase_models import ChallengeDocument, RoundDocument, TaskTypeDocument


class ChallengeService:
    def __init__(self) -> None:
        self.db = get_firestore_db()

    # Challenge CRUD
    def get_challenge(self, challenge_id: str) -> Optional[APIChallenge]:
        """Get challenge by ID"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_doc = challenge_ref.get()
        if not challenge_doc.exists:
            return None
        challenge_data = challenge_doc.to_dict()
        return APIChallenge.model_validate(challenge_data)

    def get_all_challenges(self) -> List[APIChallenge]:
        """Get all challenges"""
        challenges = []
        challenge_docs = self.db.collection('challenges').stream()

        for challenge_doc in challenge_docs:
            challenge_data = challenge_doc.to_dict()
            api_challenge = APIChallenge.model_validate(challenge_data)
            challenges.append(api_challenge)

        return challenges

    def create_challenge(self, title: str, description: str) -> APIChallenge:
        """Create a new challenge"""
        # Use Firestore autogenerated document ID
        challenge_ref = self.db.collection('challenges').document()
        challenge_id = challenge_ref.id
        
        challenge_doc = ChallengeDocument(
            id=challenge_id,
            title=title,
            description=description
        )

        data = challenge_doc.model_dump()
        self.db.collection('challenges').document(challenge_id).set(data)
        return APIChallenge.model_validate(data)

    def update_challenge(self, challenge_id: str, update: APIChallenge) -> Optional[APIChallenge]:
        """Update a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        challenge_ref.set(update.model_dump())
        return self.get_challenge(challenge_id)

    def get_rounds_by_challenge(self, challenge_id: str) -> List[APIRound]:
        """Get all rounds for a challenge"""
        challenge_ref = self.db.collection('challenges').document(challenge_id)
        if not challenge_ref.get().exists:
            return []
        
        rounds: List[APIRound] = []
        for round_doc in challenge_ref.collection('rounds').stream():
            rounds.append(APIRound.model_validate(round_doc.to_dict()))
        
        return rounds

    def get_round(self, round_id: str, challenge_id: str) -> Optional[RoundDocument]:
        ch_ref = self.db.collection('challenges').document(challenge_id)
        rd_ref = ch_ref.collection('rounds').document(round_id)
        rd_doc = rd_ref.get()
        if rd_doc.exists:
            return RoundDocument.model_validate(rd_doc.to_dict())
        return None


    def get_round_task_types_by_round(self, round_id: str, challenge_id: str) -> List[APIRoundTaskType]:
        """List task types embedded in a round document."""
        rd_doc = self.db.collection('challenges').document(challenge_id).collection('rounds').document(round_id).get()
        rd: RoundDocument = RoundDocument.model_validate(rd_doc.to_dict())
        return [APIRoundTaskType.model_validate(tt, from_attributes=True) for tt in rd.task_types]


    def update_round(self, round_data: APIRound) -> APIRound:
        rd_ref = self.db.collection('challenges').document(round_data.challenge_id).collection('rounds').document(round_data.id)
        base = RoundDocument.model_validate(round_data, from_attributes=True).model_dump()
        rd_ref.set(base)
        return round_data


    def delete_round(self, round_id: str, challenge_id: str) -> None:
        rd_ref = self.db.collection('challenges').document(challenge_id).collection('rounds').document(round_id)
        if rd_ref.get().exists:
            rd_ref.delete()
        return